# -*- coding: utf-8 -*-
"""Model_Sistem_Rekomendasi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Yd1HpKDFrC3E9KneAqhps4ebeWWHUQnO

# Import Library

Pada bagian ini, seluruh library yang dibutuhkan untuk analisis data, visualisasi, pemrosesan teks, pembuatan model machine learning, dan evaluasi dimuat.
Library seperti `pandas`, `numpy`, `matplotlib`, `seaborn`, `sklearn`, `tensorflow`, dan `textblob` merupakan komponen utama dalam proses ini.
"""

# 📊 Analisis Data
import pandas as pd
import numpy as np

# 📈 Visualisasi
import matplotlib.pyplot as plt
import seaborn as sns

# 🧹 Preprocessing
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split

# 📐 Evaluasi & Similarity
from sklearn.metrics.pairwise import cosine_similarity

# 🧠 Machine Learning - Deep Learning
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.callbacks import EarlyStopping
import nltk

# 📝 NLP (Text Processing)
from textblob import TextBlob
from sklearn.feature_extraction.text import TfidfVectorizer

# 📂 Google Colab
from google.colab import files

"""### Persiapan Resource NLP untuk TextBlob & NLTK

Mengunduh korpus dan tagger yang dibutuhkan oleh library NLTK dan TextBlob untuk analisis teks, seperti tokenisasi, part-of-speech tagging, dan klasifikasi gramatikal.
"""

nltk.download('punkt_tab')
nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')
nltk.download('tagsets')
!python -m textblob.download_corpora

"""# Upload Dataset ke Colab

Mengunggah file dataset dari komputer lokal ke lingkungan Google Colab menggunakan files.upload(). Data ini akan digunakan untuk proses analisis dan pembangunan sistem rekomendasi.
"""

# Meng-upload file
uploaded = files.upload()

"""# Read Dataset

Membaca seluruh file CSV yang telah diunggah ke dalam DataFrame menggunakan pandas.
"""

# Membaca dataset
df_user = pd.read_csv('user.csv')
df_tourism = pd.read_csv('tourism_with_id.csv')
df_rating = pd.read_csv('tourism_rating.csv')
df_package = pd.read_csv('package_tourism.csv')

"""### Menampilkan Cuplikan Dataset

Menampilkan 5 baris pertama dari setiap DataFrame untuk mendapatkan gambaran awal isi dataset:
"""

print("User Dataset:")
print(df_user.head(), "\n")

print("Tourism Dataset (with ID):")
print(df_tourism.head(), "\n")

print("Tourism Rating Dataset:")
print(df_rating.head(), "\n")

print("Package Tourism Dataset:")
print(df_package.head(), "\n")

"""#### User Dataset
- User_Id: ID unik untuk setiap pengguna.
- Location: Lokasi atau kota tempat tinggal pengguna.
- Age: Usia pengguna.


#### Tourism Dataset
- Place_Id: ID unik untuk setiap tempat wisata.
- Place_Name: Nama tempat wisata.
- Description: Deskripsi tempat wisata.
- Category: Kategori tempat wisata (misalnya: Budaya, Alam, dll).
- City: Kota tempat wisata berada.
- Price: Harga tiket masuk tempat wisata.
- Rating: Rating rata-rata dari pengguna untuk tempat wisata.
- Time_Minutes: Lama waktu yang diperlukan untuk mengunjungi tempat wisata (dalam menit).
- Coordinate: Koordinat GPS tempat wisata.
- Lat: Latitude koordinat geografis.
- Long: Longitude koordinat geografis.
- Unnamed: 11: Kolom tidak terpakai, sebaiknya dihapus.
- Unnamed: 12: Kolom tidak terpakai, sebaiknya dihapus.


#### Tourism Rating Dataset
- User_Id: ID pengguna yang memberikan rating.
- Place_Id: ID tempat wisata yang diberikan rating.
- Place_Ratings: Rating yang diberikan oleh pengguna untuk tempat wisata.

#### Package Tourism Dataset
- Package: ID unik untuk setiap paket wisata.
- City: Kota yang tercakup dalam paket wisata.
- Place_Tourism1: Tempat wisata pertama dalam paket.
- Place_Tourism2: Tempat wisata kedua dalam paket.
- Place_Tourism3: Tempat wisata ketiga dalam paket.
- Place_Tourism4: Tempat wisata keempat dalam paket (nilai missing).
- Place_Tourism5: Tempat wisata kelima dalam paket (nilai missing).

### Statistik Deskriptif Dataset User

Kode ini menampilkan statistik deskriptif dari dataset df_user, mencakup semua kolom (include='all'), baik numerik maupun kategorikal. Informasi yang ditampilkan meliputi:
- Count (jumlah entri tidak null)
- Unique (jumlah nilai unik untuk kolom kategorikal)
- Top (nilai yang paling sering muncul)
- Freq (frekuensi dari nilai yang paling sering muncul)
- Mean, Std, Min, Max (untuk kolom numerik)

Tujuannya adalah untuk memahami karakteristik dasar dari data pengguna.
"""

df_user.describe(include='all')

"""### Statistik Deskriptif Dataset Tempat Wisata"""

df_tourism.describe(include='all')

"""### Statistik Deskriptif Dataset Rating Wisata"""

df_rating.describe(include='all')

"""# EDA (Exploratory Data Analysis)
Exploratory Data Analysis (EDA) adalah tahap awal dalam proses analisis data di mana kita mengeksplorasi dan memahami karakteristik data secara menyeluruh sebelum membangun model machine learning. Tujuan utamanya adalah:
- Memahami struktur dan isi dataset.
- Mendeteksi masalah dalam data seperti missing values, duplikat, atau outlier.
- Mengidentifikasi pola, hubungan antar fitur, dan distribusi data.
- Menyediakan dasar pengambilan keputusan untuk preprocessing atau pemilihan model.

## 1. Informasi Umum Dataset

Pada bagian ini ditampilkan informasi struktural dari setiap dataset, yaitu:
- df_user: Dataset pengguna — menunjukkan jumlah entri (baris), tipe data setiap kolom, dan jumlah non-null values.
- df_tourism: Dataset tempat wisata — berisi data tentang destinasi wisata beserta ID dan kategorinya.
- df_rating: Dataset rating pariwisata — mencakup informasi tentang rating yang diberikan pengguna untuk tempat wisata tertentu.
- df_package: Dataset paket wisata — menyimpan informasi tentang paket wisata yang tersedia.

Dengan fungsi .info(), kita dapat mengecek:
- Apakah ada missing values
- Tipe data dari tiap kolom
- Jumlah total entry per dataset
"""

# Menampilkan informasi umum dari setiap dataset
print("Info User Dataset:")
print(df_user.info(), "\n")

print("Info Tourism Dataset:")
print(df_tourism.info(), "\n")

print("Info Tourism Rating Dataset:")
print(df_rating.info(), "\n")

print("Info Package Tourism Dataset:")
print(df_package.info(), "\n")

"""## 2. Pembersihan Kolom Tidak Relevan

Pada tahap ini, dilakukan penghapusan kolom-kolom yang tidak diperlukan atau tidak memiliki nilai informasi penting untuk analisis dan pemodelan. Kolom yang dihapus antara lain:
- Coordinate
- Unnamed: 11
- Unnamed: 12

Kolom-kolom ini berasal dari hasil ekspor file CSV yang kurang bersih atau tidak relevan dengan tujuan analisis. Penghapusan dilakukan secara otomatis untuk setiap dataset (user, tourism, rating, dan package) jika kolom tersebut ditemukan.
"""

# Daftar kolom yang ingin dihapus
columns_to_drop = ['Coordinate', 'Unnamed: 11', 'Unnamed: 12']

# Hapus kolom jika kolom tersebut ada
for df in [df_user, df_tourism, df_rating, df_package]:
    df.drop(columns=[col for col in columns_to_drop if col in df.columns], inplace=True)

"""## 3. Pengecekan Missing Values

Pada tahap ini, dilakukan pengecekan untuk melihat apakah ada nilai yang hilang (missing values) di dalam setiap dataset. Missing values dapat mempengaruhi kualitas model, oleh karena itu perlu dilakukan penanganan lebih lanjut seperti pengisian atau penghapusan data yang hilang.

Hasil pengecekan missing values akan menunjukkan jumlah missing values di setiap kolom pada dataset df_package, df_rating, df_tourism, dan df_user. Ini akan memberi gambaran tentang kualitas data yang dimiliki.
"""

print("Missing values in df_package:\n", df_package.isnull().sum())
print("\nMissing values in df_rating:\n", df_rating.isnull().sum())
print("\nMissing values in df_tourism:\n", df_tourism.isnull().sum())
print("\nMissing values in df_user:\n", df_user.isnull().sum())

"""## 4. Menangani Duplikat Data
Di bawah ini adalah pemeriksaan jumlah data duplikat untuk masing-masing dataset. Duplikat dapat mempengaruhi kualitas analisis dan model, sehingga penting untuk mengidentifikasinya dan mengambil tindakan yang sesuai.
"""

print("Duplicates in df_package:", df_package.duplicated().sum())
print("Duplicates in df_rating:", df_rating.duplicated().sum())
print("Duplicates in df_tourism:", df_tourism.duplicated().sum())
print("Duplicates in df_user:", df_user.duplicated().sum())

"""## 5. Visualisasi Distribusi Fitur Numerik
Bagian ini bertujuan untuk memvisualisasikan distribusi fitur numerik yang terdapat pada setiap dataset untuk membantu memahami data lebih baik.
- numeric_dfs: List ini berisi DataFrame yang hanya mencakup kolom numerik dari setiap dataset.
- titles: Daftar berisi judul untuk setiap plot yang akan ditampilkan, sesuai dengan dataset terkait.
- Loop untuk plot histogram: Setiap dataset divisualisasikan menggunakan histogram dengan 20 bin untuk menunjukkan distribusi fitur numerik yang ada. tight_layout() digunakan untuk memastikan bahwa label dan elemen plot tidak saling tumpang tindih.

Visualisasi ini membantu kita memahami sebaran data numerik, serta mendeteksi adanya pencilan atau pola distribusi tertentu di setiap dataset.
"""

# Buat list DataFrame numerik
numeric_dfs = [
    df_package.select_dtypes(include='number'),
    df_rating.select_dtypes(include='number'),
    df_tourism.select_dtypes(include='number'),
    df_user.select_dtypes(include='number')
]

# Judul plot untuk setiap DataFrame
titles = ['Package Tourism', 'Tourism Rating', 'Tourism with ID', 'User']

# Loop untuk plotting histogram setiap dataset
for df, title in zip(numeric_dfs, titles):
    df.hist(bins=20, figsize=(12, 8))
    plt.suptitle(f'Distribusi Numerik - {title}', fontsize=16)
    plt.tight_layout()
    plt.show()

"""## 6. Visualisasi Pairplot untuk Fitur Numerik
Bagian ini berfungsi untuk memvisualisasikan hubungan antar fitur numerik menggunakan pairplot. Pairplot memungkinkan kita untuk melihat distribusi dari setiap fitur dan korelasi antar fitur dalam dataset.
"""

# Ambil hanya fitur numerik dari setiap DataFrame
numeric_dfs = [
    df_package.select_dtypes(include='number'),
    df_rating.select_dtypes(include='number'),
    df_tourism.select_dtypes(include='number'),
    df_user.select_dtypes(include='number')
]

titles = ['Package Tourism', 'Tourism Rating', 'Tourism with ID', 'User']

# Plot pairplot hanya jika jumlah kolom numerik <= 5
for df, title in zip(numeric_dfs, titles):
    if df.shape[1] <= 5:  # batas maksimal kolom untuk pairplot
        print(f"Menampilkan pairplot untuk: {title}")
        sns.pairplot(df)
        plt.suptitle(f'Pairplot - {title}', y=1.02)
        plt.show()
    else:
        print(f"Pairplot dilewati untuk: {title} (jumlah kolom numerik > 5)")

"""Penjelasan:
- numeric_dfs: List ini berisi DataFrame yang hanya mencakup kolom numerik dari setiap dataset.
- titles: Daftar berisi judul untuk setiap plot yang akan ditampilkan, sesuai dengan dataset yang bersangkutan.
- Pairplot: Digunakan untuk memvisualisasikan hubungan antar fitur numerik. Namun, hanya DataFrame dengan kurang dari 5 kolom numerik yang diproses menggunakan pairplot, untuk mencegah plot yang terlalu ramai dan sulit dibaca.

Jika dataset memiliki lebih dari 5 kolom numerik, pairplot akan dilewati untuk menjaga visualisasi tetap relevan dan tidak membingungkan.

## 7. Visualisasi Heatmap Korelasi
Bagian ini bertujuan untuk menampilkan heatmap korelasi antar fitur numerik dalam setiap dataset. Heatmap korelasi memungkinkan kita untuk dengan cepat mengidentifikasi hubungan antar variabel, dengan warna yang menunjukkan tingkat korelasi antara fitur-fitur tersebut.
"""

# Ambil hanya kolom numerik dari masing-masing dataset
numeric_dfs = [
    df_package.select_dtypes(include='number'),
    df_rating.select_dtypes(include='number'),
    df_tourism.select_dtypes(include='number'),
    df_user.select_dtypes(include='number')
]

titles = ['Package Tourism', 'Tourism Rating', 'Tourism with ID', 'User']

# Tampilkan heatmap korelasi jika kolom numerik lebih dari 1
for df, title in zip(numeric_dfs, titles):
    if df.shape[1] > 1:
        plt.figure(figsize=(8, 6))
        sns.heatmap(df.corr(), annot=True, cmap='coolwarm')
        plt.title(f'Heatmap Korelasi - {title}')
        plt.tight_layout()
        plt.show()
    else:
        print(f"Heatmap dilewati untuk: {title} (jumlah kolom numerik terlalu sedikit)")

"""### Penjelasan:
- numeric_dfs: List ini berisi DataFrame yang hanya mencakup kolom numerik dari setiap dataset.
- titles: Daftar yang berisi judul untuk setiap plot yang sesuai dengan dataset yang bersangkutan.
- Heatmap: Digunakan untuk menggambarkan korelasi antar fitur numerik. Setiap sel pada heatmap mewakili korelasi antara dua fitur numerik. Korelasi positif ditandai dengan warna yang lebih terang, sementara korelasi negatif ditandai dengan warna yang lebih gelap. Jika dataset hanya memiliki satu kolom numerik, heatmap akan dilewati.


### Interpretasi:
- Korelasi tinggi: Jika nilai korelasi mendekati 1 atau -1, maka ada hubungan yang sangat kuat antara dua fitur.
- Korelasi rendah: Jika nilai korelasi mendekati 0, maka hubungan antar fitur sangat lemah atau hampir tidak ada.

### Manfaat:
- Membantu untuk memahami hubungan antar fitur.
- Bisa menjadi indikasi untuk pemilihan fitur atau penghapusan fitur yang sangat berkorelasi tinggi (multikolinearitas).

## 8. Visualisasi Distribusi Kategorikal
Bagian ini digunakan untuk menampilkan distribusi fitur kategorikal pada setiap dataset. Visualisasi yang digunakan berupa countplot dan barplot, untuk memberikan gambaran mengenai seberapa banyak setiap kategori muncul dalam dataset.
"""

categorical_dfs = [
    df_package.select_dtypes(include='object'),
    df_rating.select_dtypes(include='object'),
    df_tourism.select_dtypes(include='object'),
    df_user.select_dtypes(include='object')
]

titles = ['Package Tourism', 'Tourism Rating', 'Tourism with ID', 'User']

for df, title in zip(categorical_dfs, titles):
    for col in df.columns:
        unique_vals = df[col].nunique()
        if unique_vals < 30:
            # Visualisasi semua kategori
            plt.figure(figsize=(6, 4))
            sns.countplot(y=col, data=df, order=df[col].value_counts().index)
            plt.title(f'Distribusi {col} - {title}')
            plt.tight_layout()
            plt.show()
        else:
            # Visualisasi top 15 kategori saja
            print(f"Kolom '{col}' di dataset '{title}' memiliki terlalu banyak kategori ({unique_vals}) - menampilkan top 15.")
            top_categories = df[col].value_counts().nlargest(15)
            plt.figure(figsize=(6, 6))
            sns.barplot(y=top_categories.index, x=top_categories.values, palette='viridis')
            plt.title(f'Top 15 {col} - {title}')
            plt.xlabel('Jumlah')
            plt.tight_layout()
            plt.show()

"""### Penjelasan:
- categorical_dfs: List yang berisi DataFrame yang hanya mencakup kolom bertipe kategorikal (tipe object) dari setiap dataset.
- titles: Daftar judul untuk setiap plot berdasarkan dataset yang bersangkutan.
- Distribusi Kategorikal: Jika kolom kategorikal memiliki kurang dari 30 kategori, kita menggunakan countplot untuk menampilkan distribusi kategori tersebut. Jika lebih dari 30 kategori, kita hanya menampilkan top 15 kategori teratas menggunakan barplot.

###  Interpretasi:
- Countplot: Digunakan untuk visualisasi frekuensi setiap kategori. Jika kolom memiliki sedikit kategori (misal: lokasi, kategori tempat wisata), countplot sangat cocok untuk menampilkan distribusinya.
- Barplot: Digunakan jika jumlah kategori lebih banyak. Menampilkan 15 kategori teratas berdasarkan frekuensi kemunculan.

### Manfaat:
- Membantu memahami distribusi data kategorikal dan memeriksa ketidakseimbangan kelas pada kolom kategorikal.
- Memberikan wawasan untuk memperbaiki data seperti kategori yang jarang muncul (outlier kategorikal), atau memilih fitur kategorikal mana yang penting untuk model.

## 9. Statistik Deskriptif Fitur Kategorikal
Bagian ini akan menampilkan statistik deskriptif untuk kolom-kolom bertipe kategorikal (tipe data object) di setiap dataset. Statistik deskriptif ini memberikan informasi tentang distribusi nilai dalam kolom kategorikal.
"""

# Statistik deskriptif fitur kategorikal
for df, title in zip(categorical_dfs, titles):
    print(f"Statistik deskriptif fitur kategorikal - {title}:\n")
    # Tambahkan cek untuk memastikan DataFrame tidak kosong (memiliki kolom)
    if not df.empty and df.shape[1] > 0:
        print(df.describe(include='object'), "\n")
    else:
        print(f"DataFrame '{title}' tidak memiliki kolom bertipe 'object'.")
        print("\n")

"""### Penjelasan:

1. df.describe(include='object'):
- Fungsi ini memberikan statistik deskriptif untuk kolom bertipe object (biasanya untuk kolom kategorikal). Statistik yang dihasilkan antara lain:
  - count: jumlah data yang tidak kosong.
  - unique: jumlah nilai unik dalam kolom.
  - top: nilai yang paling sering muncul.
  - freq: frekuensi kemunculan nilai yang paling sering.
2. Penggunaan Looping for df, title in zip(categorical_dfs, titles):
- Melalui looping ini, kode akan menjalankan statistik deskriptif untuk setiap DataFrame yang berisi kolom-kolom kategorikal.

### Interpretasi Hasil:
- count: Memberikan informasi seberapa banyak data dalam kolom tersebut, menghindari adanya nilai yang hilang (NaN).
- unique: Memberikan jumlah kategori yang berbeda dalam kolom tersebut, memberi gambaran tentang keragaman data kategorikal.
- top: Menunjukkan kategori yang paling sering muncul, memberikan insight tentang kategori dominan dalam dataset.
- freq: Memberikan frekuensi kemunculan kategori yang paling sering.

### Manfaat:
- Mengetahui distribusi nilai dalam kolom kategorikal membantu kita memahami variasi dan konsentrasi data.
- Membantu dalam mendeteksi data yang memiliki kategori dominan yang mungkin mempengaruhi model rekomendasi.
- Dapat menunjukkan apakah data tersebut memiliki banyak kategori yang unik atau apakah ada kategori yang sangat jarang, yang penting untuk desain model rekomendasi.

### 10. Distribusi Jumlah Rating per User dan per Tempat Wisata
Visualisasi ini bertujuan untuk memahami pola interaksi pengguna terhadap tempat wisata berdasarkan data rating. Terdapat dua histogram yang ditampilkan:

Distribusi Jumlah Rating per User
Menunjukkan seberapa banyak rating yang diberikan oleh masing-masing pengguna. Ini berguna untuk mengetahui tingkat keaktifan pengguna dalam memberikan penilaian terhadap tempat wisata. Jika sebagian besar pengguna hanya memberikan sedikit rating, maka data bersifat sparsity dan bisa memengaruhi performa collaborative filtering.

Distribusi Jumlah Rating per Tempat Wisata
Menampilkan jumlah rating yang diterima oleh masing-masing tempat wisata. Visualisasi ini membantu mengidentifikasi tempat-tempat yang populer (sering dinilai) dan tempat yang kurang populer (jarang dinilai), yang dapat memengaruhi akurasi sistem rekomendasi. Tempat dengan rating terbanyak biasanya menjadi kandidat kuat untuk direkomendasikan.

Kedua visualisasi ini penting dalam proses eksplorasi data untuk memberikan gambaran umum tentang distribusi interaksi antara pengguna dan item (tempat wisata) sebelum membangun sistem rekomendasi.
"""

# Distribusi jumlah rating per user
df_rating['User_Id'].value_counts().hist(bins=20)
plt.title("Distribusi Jumlah Rating per User")
plt.xlabel("Jumlah Rating")
plt.ylabel("Jumlah User")
plt.show()

# Distribusi jumlah rating per tempat
df_rating['Place_Id'].value_counts().hist(bins=20)
plt.title("Distribusi Jumlah Rating per Tempat")
plt.xlabel("Jumlah Rating")
plt.ylabel("Jumlah Tempat")
plt.show()

"""## 11. Distribusi Data Berdasarkan Lokasi, Kategori, dan Kota
Bagian ini menampilkan informasi terkait lokasi pengguna, kategori tempat wisata, dan distribusi kota pada paket wisata.
"""

# Lihat 10 lokasi teratas dari user
print("10 Lokasi dengan jumlah user terbanyak:\n", df_user['Location'].value_counts().head(10))

# Lihat 10 kategori tempat wisata terbanyak
print("\n10 Kategori Tempat Wisata Terbanyak:\n", df_tourism['Category'].value_counts().head(10))

# Lihat kota yang paling sering muncul dalam paket
print("\nDistribusi kota dalam Package Tourism:\n", df_package['City'].value_counts())

"""### Penjelasan:
1. Lokasi Pengguna (df_user['Location']):
- Menampilkan 10 lokasi teratas berdasarkan jumlah pengguna yang terdaftar di lokasi tersebut.
- Membantu untuk melihat di mana pengguna lebih banyak beraktivitas atau berasal.

2. Kategori Tempat Wisata (df_tourism['Category']):
- Menampilkan 10 kategori tempat wisata terbanyak.
- Membantu untuk melihat kategori tempat wisata yang paling sering dipilih oleh pengguna.

3. Kota dalam Paket Wisata (df_package['City']):
- Menampilkan distribusi kota dalam dataset paket wisata.
- Memberikan informasi tentang kota-kota yang paling banyak muncul dalam paket wisata yang ditawarkan.

### Interpretasi:
- Lokasi Pengguna: Melihat lokasi dengan jumlah pengguna terbanyak memberikan gambaran tentang konsentrasi pengguna. Ini bisa membantu dalam merancang rekomendasi yang lebih relevan berdasarkan lokasi geografis pengguna.
- Kategori Tempat Wisata: Mengetahui kategori tempat wisata terbanyak memberi wawasan tentang preferensi umum pengguna terhadap jenis tempat wisata. Ini bisa digunakan untuk menyesuaikan rekomendasi tempat wisata berdasarkan tren popularitas.
- Kota dalam Paket Wisata: Menunjukkan distribusi kota dalam paket wisata, memberikan gambaran tentang kota-kota yang lebih sering muncul dalam paket wisata yang ditawarkan, dan ini bisa menjadi informasi penting untuk merancang penawaran wisata lebih baik.

### Manfaat:
- Memberikan informasi tentang distribusi pengguna, tempat wisata, dan kota pada dataset yang membantu dalam perencanaan model rekomendasi berbasis lokasi dan kategori.
- Memberikan wawasan terkait ketidakseimbangan data, seperti lokasi atau kota yang lebih dominan, yang bisa mempengaruhi cara sistem rekomendasi bekerja.

# Data Preprocessing
Data preprocessing adalah tahap awal dalam proses analisis data atau pembuatan model machine learning yang bertujuan untuk membersihkan dan mempersiapkan data mentah agar layak untuk dianalisis. Data yang diperoleh dari berbagai sumber sering kali mengandung noise, nilai kosong (missing values), duplikasi, atau outlier yang dapat memengaruhi kualitas hasil analisis atau performa model.

Preprocessing merupakan langkah krusial karena kualitas data sangat menentukan kualitas output dari model atau analisis yang dilakukan. Dengan data yang bersih dan terstruktur, kita bisa mendapatkan insight yang lebih akurat dan model yang lebih andal.

### 1. Penanganan Missing Values
Untuk memastikan kualitas data, dilakukan pemeriksaan dan penghapusan nilai kosong (missing values) pada setiap dataset (df_user, df_rating, df_tourism, dan df_package). Proses ini dilakukan menggunakan fungsi dropna(), diikuti dengan pengecekan ulang untuk memastikan tidak ada nilai yang hilang tersisa.
"""

# Drop missing values
df_user.dropna(inplace=True)
df_rating.dropna(inplace=True)
df_tourism.dropna(inplace=True)
df_package.dropna(inplace=True)

# Cek jumlah missing values setelah di-drop
print("Setelah dihapus (missing values):")
print("df_user:\n", df_user.isnull().sum(), "\n")
print("df_rating:\n", df_rating.isnull().sum(), "\n")
print("df_tourism:\n", df_tourism.isnull().sum(), "\n")
print("df_package:\n", df_package.isnull().sum(), "\n")

"""### 2. penghapusan data duplikat
Pada tahap awal preprocessing, dilakukan penghapusan data yang bersifat duplikat pada seluruh dataframe yang digunakan, yaitu: df_user, df_rating, `dfdf_tourism, dan df_package. Kebera

Langkah ini memastikan bahwa setiap entri dalam dataset bersifat unik dan valid sebelum dilakukan proses lebih lanjut seperti penanganan nilai yang hilang atau pengkodean data. Setelah penghapusan, dilakukan pengecekan ulang untuk mem
"""

# Hapus data duplikat
df_user.drop_duplicates(inplace=True)
df_rating.drop_duplicates(inplace=True)
df_tourism.drop_duplicates(inplace=True)
df_package.drop_duplicates(inplace=True)

# Cek kembali jumlah duplikat setelah penghapusan
print("Setelah dihapus (duplikat):")
print("df_user:", df_user.duplicated().sum())
print("df_rating:", df_rating.duplicated().sum())
print("df_tourism:", df_tourism.duplicated().sum())
print("df_package:", df_package.duplicated().sum())

"""### 3. Deteksi Outlier Menggunakan Boxpl
Untuk mengidentifikasi adanya outlier dalam data numerik, dilakukan visualisasi boxplot pada masing-masing dataframe: df_package, `df_ratindf_rating, `df_pariwisata_df_tourism, dan df_user.

Langkah ini penting dilakukan sebelum melakukan normalisasi atau proses machine learning lainnya, karena outlier dapat mempengaruhi performa model secara signifikan. Dengan visualisasi ini, pengguna dapat dengan mudah mengamati distribusi data dan menentukan perlakuan selanjutnya terhadap outlier
"""

# Ambil fitur numerik
numeric_dfs = [
    df_package.select_dtypes(include='number'),
    df_rating.select_dtypes(include='number'),
    df_tourism.select_dtypes(include='number'),
    df_user.select_dtypes(include='number')
]

titles = ['Package Tourism', 'Tourism Rating', 'Tourism with ID', 'User']

# Plot boxplot
for df, title in zip(numeric_dfs, titles):
    if df.shape[1] > 0:
        plt.figure(figsize=(10, 5))
        sns.boxplot(data=df)
        plt.title(f'Boxplot - {title}')
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.show()

"""### 4. Menghapus Outlier Menggunakan Metode IQR
Pada bagian ini, dilakukan pembersihan data dari nilai-nilai ekstrem (outlier) menggunakan metode Interquartile Range (IQR). Outlier dapat mempengaruhi hasil analisis dan performa model. Oleh karena itu, penting untuk menghapusnya.

Fungsi remove_outliers_iqr digunakan untuk memfilter data berdasarkan nilai Q1 (kuartil bawah) dan Q3 (kuartil atas), dengan batas toleransi sebesar 1.5 * IQR. Fungsi ini diterapkan ke seluruh kolom numerik dari beberapa dataset, seperti df_user, df_rating, df_tourism, dan df_package. Sebelum dan sesudah proses, ukuran dataset dibandingkan untuk mengetahui seberapa banyak data yang terdeteksi sebagai outlier dan dihapus.
"""

# Fungsi untuk hapus outlier berdasarkan IQR
def remove_outliers_iqr(df, columns):
    for col in columns:
        # Add a check to see if the column exists
        if col not in df.columns:
            print(f"Error: Column '{col}' not found in DataFrame. Available columns: {df.columns.tolist()}")
            continue # Skip to the next column if not found
        Q1 = df[col].quantile(0.25)
        Q3 = df[col].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        df = df[(df[col] >= lower_bound) & (df[col] <= upper_bound)]
    return df

# Simpan jumlah sebelum
print("Jumlah data sebelum outlier removal:")
print("df_user:", df_user.shape)
print("df_rating:", df_rating.shape)
print("df_tourism:", df_tourism.shape)
print("df_package:", df_package.shape, "\n")

# Add this line to check columns before the call that fails
print("Columns in df_rating before outlier removal:", df_rating.columns.tolist())

# Terapkan ke dataset (tentukan kolom numerik)
df_user = remove_outliers_iqr(df_user, df_user.select_dtypes(include='number').columns)
df_rating = remove_outliers_iqr(df_rating, ['Place_Ratings'])  # rating saja
df_tourism = remove_outliers_iqr(df_tourism, df_tourism.select_dtypes(include='number').columns)
df_package = remove_outliers_iqr(df_package, df_package.select_dtypes(include='number').columns)

# Simpan jumlah setelah
print("Jumlah data setelah outlier removal:")
print("df_user:", df_user.shape)
print("df_rating:", df_rating.shape)
print("df_tourism:", df_tourism.shape)
print("df_package:", df_package.shape)

"""### 5. Visualisasi Boxplot setelah Penghapusan Outlier
Pada tahap ini, dilakukan visualisasi menggunakan boxplot untuk masing-masing dataset (User, Rating, Tourism, dan Package). Boxplot digunakan untuk:
- Melihat distribusi data numerik
- Mengidentifikasi outlier secara visual
- Memahami sebaran dan variasi data

Setiap grafik menampilkan kolom-kolom numerik dari masing-masing DataFrame. Proses ini membantu dalam validasi apakah metode penghapusan outlier sebelumnya telah bekerja secara efektif.
"""

# Visualisasi boxplot setiap DataFrame
datasets = [(df_user, 'User'), (df_rating, 'Rating'), (df_tourism, 'Tourism'), (df_package, 'Package')]

for df, name in datasets:
    numeric_cols = df.select_dtypes(include='number').columns
    if len(numeric_cols) > 0:
        plt.figure(figsize=(12, 6))
        sns.boxplot(data=df[numeric_cols])
        plt.title(f'Boxplot Fitur Numerik - {name}')
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.show()

"""# Modeling
Pada tahap Modeling, dilakukan pembangunan sistem rekomendasi yang bertujuan untuk memberikan saran tempat wisata kepada pengguna berdasarkan preferensi dan pola interaksi yang tersedia dalam data. Sistem rekomendasi ini memainkan peran penting dalam membantu pengguna menemukan destinasi yang relevan, menarik, dan sesuai dengan minat mereka, terutama ketika jumlah pilihan sangat banyak.

Dalam proyek ini, digunakan dua pendekatan utama:

### 1. Content-Based Filtering (CBF)
Content-Based Filtering adalah metode rekomendasi yang memanfaatkan karakteristik atau konten dari item (dalam hal ini: tempat wisata) untuk mencari kemiripan antar item. CBF bekerja dengan menganalisis informasi seperti nama tempat dan kategori wisata untuk membentuk representasi tekstual, lalu menghitung tingkat kemiripan antar tempat menggunakan teknik seperti TF-IDF dan cosine similarity. Tempat-tempat yang memiliki konten serupa akan direkomendasikan kepada pengguna yang tertarik pada tempat tertentu.

Kelebihan dari pendekatan ini adalah:
- Tidak bergantung pada data pengguna lain.
- Dapat bekerja dengan baik meskipun jumlah interaksi pengguna sedikit (cold-start).


### 2. Collaborative Filtering (CF)
Collaborative Filtering adalah metode rekomendasi yang memanfaatkan interaksi pengguna terhadap item, seperti memberikan rating atau ulasan. Dalam pendekatan ini, sistem belajar dari pola rating pengguna-pengguna lain untuk memprediksi ketertarikan pengguna terhadap tempat yang belum dikunjungi.

Model yang digunakan adalah model berbasis neural network (Neural Collaborative Filtering), di mana setiap pengguna dan tempat wisata direpresentasikan dalam bentuk embedding—vektor berdimensi rendah yang dilatih selama proses pelatihan. Output dari model ini adalah prediksi skor rating yang bisa digunakan untuk menghasilkan rekomendasi tempat terbaik bagi setiap pengguna.

Kelebihan dari pendekatan ini:
- Mampu menangkap preferensi tersembunyi pengguna.
- Semakin banyak data interaksi, semakin baik kualitas rekomendasi.

## Content-Based Filtering (CBF)

### 1. Visualisasi Distribusi Kategori Tempat Wisata

Langkah awal dalam Content-Based Filtering adalah memahami karakteristik dari data tempat wisata. Salah satu informasi penting yang dapat dianalisis adalah kategori dari masing-masing destinasi wisata. Visualisasi ini bertujuan untuk melihat sebaran jumlah tempat wisata berdasarkan kategori seperti budaya, alam, sejarah, dan sebagainya.

Dengan menggunakan grafik batang, kita dapat dengan mudah mengidentifikasi kategori yang paling dominan maupun yang jarang muncul dalam dataset. Informasi ini juga bermanfaat untuk memahami potensi kesamaan antar tempat dalam proses rekomendasi berbasis konten nantinya.
"""

# Visualisasi distribusi kategori tempat wisata
plt.figure(figsize=(10, 6))
sns.countplot(data=df_tourism, x='Category', palette='Set2')
plt.title('Distribusi Kategori Tempat Wisata')
plt.xticks(rotation=45, ha="right")
plt.xlabel('Kategori')
plt.ylabel('Jumlah')
plt.tight_layout()
plt.show()

"""### 2. Analisis Part-of-Speech (POS) pada Nama Tempat Wisata
Untuk mendalami lebih jauh karakteristik dari nama tempat wisata, dilakukan analisis Part-of-Speech (POS) menggunakan pustaka TextBlob. POS Tagging bertujuan untuk mengidentifikasi jenis kata seperti kata benda (noun), kata sifat (adjective), kata kerja (verb), dan lainnya dari kumpulan nama tempat.

Dengan menggabungkan semua nama tempat menjadi satu teks, kita dapat menganalisis frekuensi masing-masing jenis kata yang muncul. Visualisasi ini akan memberikan gambaran mengenai struktur umum penamaan tempat wisata, misalnya apakah lebih banyak menggunakan kata benda atau kata sifat.

Informasi POS ini juga bisa memberikan insight tambahan jika ingin mengembangkan model rekomendasi yang mempertimbangkan karakter linguistik dari nama tempat.
"""

# POS Tagging dengan TextBlob pada nama tempat
blob = TextBlob(" ".join(df_tourism['Place_Name']))
pos_df = pd.DataFrame(blob.tags, columns=['word', 'pos'])
pos_counts = pos_df['pos'].value_counts()

plt.figure(figsize=(12, 8))
sns.barplot(x=pos_counts.index, y=pos_counts.values, palette='Set1')
plt.title('Distribusi Part-of-Speech (POS) pada Nama Tempat Wisata')
plt.xlabel('POS Tag')
plt.ylabel('Jumlah')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""### 3. Visualisasi Bigram Menggunakan TF-IDF pada Nama Tempat Wisata
Pada bagian ini, dilakukan analisis terhadap bigram, yaitu kombinasi dua kata yang muncul secara berurutan dalam nama tempat wisata. Untuk menghitung bobot kemunculan bigram, digunakan pendekatan TF-IDF (Term Frequency-Inverse Document Frequency) yang tidak hanya mempertimbangkan frekuensi kata, tetapi juga signifikansi relatifnya di seluruh dokumen.

Tujuan dari analisis ini adalah untuk mengidentifikasi pasangan kata yang paling sering dan paling penting dalam nama-nama tempat wisata. Hal ini dapat memberikan insight tentang pola penamaan, misalnya apakah tempat wisata sering menggunakan kata seperti "Taman Wisata", "Pantai Indah", atau kombinasi umum lainnya.

Visualisasi ini membantu kita memahami struktur frasa yang dominan, yang dapat digunakan dalam pengembangan model Content-Based Filtering untuk meningkatkan akurasi rekomendasi berdasarkan kemiripan nama atau kategori tempat.
"""

# Visualisasi Bigram TF-IDF
tfidf_bigram = TfidfVectorizer(ngram_range=(2, 2), stop_words='english')
tfidf_bigram_matrix = tfidf_bigram.fit_transform(df_tourism['Place_Name'])
total_bigram = tfidf_bigram_matrix.sum(axis=0)
bigram_freq = [(word, total_bigram[0, idx]) for word, idx in tfidf_bigram.vocabulary_.items()]
bigram_df = pd.DataFrame(sorted(bigram_freq, key=lambda x: x[1], reverse=True)[:20], columns=['Bigram', 'Count'])

plt.figure(figsize=(15, 7))
sns.barplot(x='Bigram', y='Count', data=bigram_df, palette='viridis')
plt.title('Distribusi Bigram pada Nama Tempat Wisata')
plt.xlabel('Bigram')
plt.ylabel('Frekuensi')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""### 4. Visualisasi Trigram Menggunakan TF-IDF pada Nama Tempat Wisata
Setelah analisis bigram, dilakukan pula analisis terhadap trigram, yaitu kombinasi tiga kata yang muncul berurutan dalam nama tempat wisata. Seperti sebelumnya, metode TF-IDF digunakan untuk mengukur pentingnya trigram yang muncul, bukan hanya berdasarkan frekuensinya tetapi juga berdasarkan tingkat kekhususan trigram di seluruh data.

Trigram dapat memberikan informasi yang lebih kontekstual dibanding unigram (satu kata) atau bigram, karena tiga kata berturut-turut cenderung membentuk frasa yang lebih bermakna atau spesifik. Misalnya, frasa seperti "Taman Wisata Alam" atau "Pantai Pasir Putih" bisa muncul sebagai trigram yang signifikan.

Visualisasi ini membantu mengidentifikasi pola atau struktur umum dalam penamaan tempat wisata yang bisa dimanfaatkan lebih lanjut untuk proses ekstraksi fitur dalam sistem rekomendasi berbasis konten.
"""

# Visualisasi Trigram TF-IDF
tfidf_trigram = TfidfVectorizer(ngram_range=(3, 3), stop_words='english')
tfidf_trigram_matrix = tfidf_trigram.fit_transform(df_tourism['Place_Name'])
total_trigram = tfidf_trigram_matrix.sum(axis=0)
trigram_freq = [(word, total_trigram[0, idx]) for word, idx in tfidf_trigram.vocabulary_.items()]
trigram_df = pd.DataFrame(sorted(trigram_freq, key=lambda x: x[1], reverse=True)[:20], columns=['Trigram', 'Count'])

plt.figure(figsize=(15, 7))
sns.barplot(x='Trigram', y='Count', data=trigram_df, palette='coolwarm')
plt.title('Distribusi Trigram pada Nama Tempat Wisata')
plt.xlabel('Trigram')
plt.ylabel('Frekuensi')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""### 5. Penggabungan Fitur Konten
Pada tahap ini, kolom Place_Name dan Category digabung menjadi satu fitur teks (combined_features). Tanda pemisah | pada kategori diubah menjadi spasi agar lebih cocok untuk analisis teks.

Fitur ini digunakan untuk membentuk representasi konten tempat wisata, yang nantinya akan diproses menggunakan TF-IDF dalam metode Content-Based Filtering.
"""

df_tourism['combined_features'] = (
    df_tourism['Place_Name']
    + ' '
    + df_tourism['Category'].str.replace('|', ' ', regex=False)
)

"""### 6. Ekstraksi Fitur dengan TF-IDF
TF-IDF (Term Frequency–Inverse Document Frequency) digunakan untuk mengubah data teks (combined_features) menjadi representasi numerik. Teknik ini menekankan kata-kata yang penting dan mengurangi bobot kata umum (stop words).

"""

# TF-IDF Vectorizer
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df_tourism['combined_features'])

"""### 7. Perhitungan Cosine Similarity
Cosine Similarity digunakan untuk mengukur tingkat kemiripan antar tempat wisata berdasarkan representasi vektor dari TF-IDF. Nilai kemiripan ini disusun dalam bentuk matriks, sehingga kita dapat melihat seberapa mirip satu tempat dengan tempat lainnya.

Hasilnya disimpan dalam similarity_df, yang menjadi dasar untuk sistem rekomendasi berbasis konten.
"""

# Cosine Similarity Matrix
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)
similarity_df = pd.DataFrame(cosine_sim, index=df_tourism['Place_Name'], columns=df_tourism['Place_Name'])

"""### 8. similarity_df
similarity_df adalah DataFrame yang berisi skor kemiripan (cosine similarity) antar tempat wisata. Setiap baris dan kolom mewakili satu tempat wisata, dan nilai di sel menunjukkan tingkat kemiripan antara dua tempat. Nilai berkisar dari 0 (tidak mirip) hingga 1 (sangat mirip). Data ini menjadi dasar untuk memberikan rekomendasi tempat wisata yang mirip dengan tempat yang dipilih pengguna.
"""

similarity_df

"""### 9. Mapping Nama Tempat ke Index
Kode ini membuat Series bernama indices yang berfungsi untuk memetakan nama tempat wisata ke indeks baris pada dataframe df_tourism. Mapping ini sangat penting dalam proses Content-Based Filtering, karena sistem perlu mengetahui baris ke berapa dari suatu tempat wisata berdasarkan nama yang dimasukkan oleh pengguna (misalnya saat pengguna memilih tempat favoritnya sebagai input rekomendasi).

Misalnya, saat pengguna memilih tempat wisata "Museum Taman Prasasti", sistem menggunakan indices['Museum Taman Prasasti'] untuk menemukan indeks baris tempat tersebut, lalu mengambil vektor TF-IDF-nya dan membandingkan dengan tempat lain untuk menghasilkan rekomendasi berdasarkan kemiripan konten.

Fungsi drop_duplicates() digunakan untuk menghindari duplikasi nama tempat wisata agar mapping yang dibuat unik dan tidak ambigu.
"""

# Buat mapping nama tempat ke index
indices = pd.Series(df_tourism.index, index=df_tourism['Place_Name']).drop_duplicates()

"""### 10. Fungsi Rekomendasi Tempat Wisata
Fungsi get_recommendations digunakan untuk memberikan rekomendasi tempat wisata yang mirip dengan nama tempat yang diberikan sebagai input. Prosesnya meliputi:
- Mengecek apakah nama tempat ada dalam data.
- Mengambil indeks tempat tersebut.
- Menghitung skor kesamaan (cosine similarity) terhadap semua tempat lain.
- Mengurutkan skor dan mengambil 10 tempat teratas yang paling mirip (selain dirinya sendiri).
- Mengembalikan data tempat yang direkomendasikan dalam bentuk DataFrame.
"""

# Fungsi rekomendasi
def get_recommendations(place_name, cosine_sim=cosine_sim):
    if place_name not in indices:
        return f"❌ Nama tempat '{place_name}' tidak ditemukan dalam data."

    idx = indices[place_name]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:11]  # Ambil top 10, selain dirinya sendiri
    place_indices = [i[0] for i in sim_scores]

    return df_tourism.iloc[place_indices][['Place_Id', 'Place_Name', 'Category', 'Description']]

"""### 11. Contoh Penggunaan Fungsi Rekomendasi
Contoh berikut menunjukkan cara memanggil fungsi get_recommendations dengan memasukkan nama tempat wisata, dalam hal ini "Museum Taman Prasasti". Fungsi akan menampilkan daftar tempat wisata lain yang memiliki kemiripan konten berdasarkan nama dan kategori menggunakan metode Content-Based Filtering (CBF).
"""

# Contoh pemanggilan fungsi (non-interaktif, tidak pakai input())
get_recommendations("Museum Taman Prasasti")

"""## Collaborative Filtering (CF)

### 1. Penggabungan Data untuk Collaborative Filtering
Langkah ini menggabungkan tiga data utama: data rating (df_rating), data pengguna (df_user), dan data tempat wisata (df_tourism). Penggabungan dilakukan berdasarkan User_Id dan Place_Id, sehingga membentuk satu dataframe komprehensif (df) yang memuat informasi lengkap tentang siapa yang memberi rating, terhadap tempat wisata mana, dan informasi kontennya.
"""

# Menggabungkan data rating dengan data user dan tourism
df = df_rating.merge(df_user, on='User_Id').merge(df_tourism, on='Place_Id')

"""### 2. Encoding ID Pengguna dan Tempat
Pada tahap ini, dilakukan transformasi ID pengguna (User_Id) dan ID tempat (Place_Id) menjadi bentuk numerik menggunakan LabelEncoder. Hal ini penting agar data dapat digunakan sebagai input dalam model machine learning.
- df['user'] dan df['place'] berisi representasi numerik dari pengguna dan tempat.
- num_users dan num_places menyimpan jumlah unik pengguna dan tempat wisata, yang dibutuhkan untuk menentukan ukuran embedding dalam model rekomendasi.
"""

user_encoder = LabelEncoder()
place_encoder = LabelEncoder()

df['user'] = user_encoder.fit_transform(df['User_Id'])
df['place'] = place_encoder.fit_transform(df['Place_Id'])

num_users = df['user'].nunique()
num_places = df['place'].nunique()

"""### 3. Normalisasi Rating
Sebelum pelatihan model, rating dari pengguna perlu dinormalisasi agar berada dalam rentang 0 hingga 1. Ini dilakukan agar model lebih stabil dan cepat konvergen saat proses training.
- min_rating dan max_rating: mencari nilai rating minimum dan maksimum.
- rating_normalized: menghitung nilai rating yang telah dinormalisasi menggunakan rumus:

![Cuplikan layar 2025-05-27 230843.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABGcAAADGCAYAAAB/2O0wAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAHnFSURBVHhe7d15fEzX/z/w12QSWQaJLaZaImEitpCiEltDqyG2RDUf3yaoRklRoki1iErpYo+2lqJFRSu0FFVBP/K1JLE1hIpILImGkIYEE9km8/vjO3N/uXcmyQSRxev5eMzjYc49d+Zm5txrzvue8z4yR0dHLYiIiIiIiIiIqEqYSQuIiIiIiIiIiOjZYXCGiIiIiIiIiKgKMThDRERERERERFSFGJwhIiIiIiIiIqpCDM4QEREREREREVUhBmeIiIiIiIiIiKoQgzNERERERERERFWIwRkiIiIiIiIioirE4AwRERERERERURVicIaIiIiIiIiIqAoxOENEREREREREVIUYnCEiIiIiIiIiqkIMzhARERERERERVSEGZ4iIiIiIiIiIqhCDM0REREREREREVYjBGSIiIiIiIiKiKsTgDBERERERERFRFWJwhoiIiIiIiIioCjE4Q0RERERERERUhRicISIiIiIiIiKqQgzOEBERERERERFVIQZniIiIiIiIiIiqEIMzRERERERERERViMEZIiIiIiIiIqIqxOAMEREREREREVEVYnCGiIiIiIiIiKgKMThDRERERERERFSFGJwhIiIiIiIiIqpCDM4QEREREREREVUhBmeIiIiIiIiIiKoQgzNERERERERERFWIwRkiIiIiIiIioirE4AwRERERERERURVicIaIiIiIiIiIqAoxOENEREREREREVIUYnCEiIiIiIiIiqkIMzhARERERERERVSEGZ4iIiIiIiIiIqhCDM0REREREREREVYjBGSIiIiIiIiKiKsTgDBERERERERFRFWJwhoiIiIiIiIioCjE4Q0RERERERERUhRicISIiIiIiIiKqQgzOEBERERERERFVIQZniIiIiJ4Tfn5+2LNnD+Lj47Fnzx74+flJqxBVS2y7VJo+ffogMjIS8fHxOHToEIKCgqRViGoEeYMGDT6VFhIRERFR7eLv749Zs2ahefPmsLKygr29PXr06AGNRoMzZ85IqxNVG2y7VBpPT0988cUXcHZ2hpWVFRo0aAB3d3c0btwY0dHR0upE1RpHzhARERE9B954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rRa3b9/GlStXcOfOHVF9e3t7uLi4oGHDhqLrYEJCAhYsWID4+HhR/dqGwRkiIiIiomoiICAA/v7+aN26tcmrfOXm5iI+Ph7r1q3DkSNHpJuJiKqUl5cXxo8fj3bt2sHS0lK62aj8/HwkJSVh06ZNj73SU03D4AwRERERUTWjVCoxbNgwdO7cGc2bN4e1tTUaN26MoqIiZGZmIjc3F4mJiTh69Cj2798v3Z2IqNpRKBTw8fFBt27d4OTkBEtLS9jb2wO6PDX5+flISUnB8ePHsX//fqjVaulL1GoMzhARERERERERVSEupU1EREREREREVIUYnCEiIiIiIiIiqkIMzhARERERERERVSEGZ4iIiIiIiIiIqhCDM0REREREREREVYjBGSIiIiIiIiKiKsTgDBERERERERFRFWJwhoiIiIiIiIioCjE4Q0RERERERERUhRicISIiIiIiIiKqQgzOEBERERERERFVIQZniIiIiIiIiIiqEIMzRERERERERERViMEZIiIiIiIiIqIqxOAMEREREREREVEVYnCGiIiIiIiIiKgKMThDRERERERERFSFGJwhIiIiIiIiIqpCDM4QEREREREREVUhBmeIiIiIiIiIiKoQgzNERERERERERFWIwRkiIiIiIiIioirE4AwRERERERERURVicIaIiIiIiIiIqAoxOENEREREREREVIUYnCEiIiIiIiIiqkIMzhARERERERERVSEGZ4iIiIiIiIiIqhCDM0REREREREREVYjBGSIiIiIiIiKiKsTgDBERERERERFRFWJwhoiIiIiIiIioCjE4Q0RERERERERUhRicISIiIiIiIiKqQgzOEBERERERERFVIQZniIiIiIiIiIiq0P8DuM+LCxxIrWwAAAAASUVORK5CYII=)

"""

min_rating = df['Place_Ratings'].min()
max_rating = df['Place_Ratings'].max()

df['rating'] = df['Place_Ratings'].astype(np.float32)
df['rating_normalized'] = (df['rating'] - min_rating) / (max_rating - min_rating)

"""### 4.Pembagian Data untuk Pelatihan dan Validasi
Langkah ini memisahkan fitur (x) dan label (y), lalu membagi data menjadi 80% untuk pelatihan dan 20% untuk validasi menggunakan train_test_split.
- x: pasangan (user, place) sebagai input.
- y: rating yang telah dinormalisasi sebagai target.

Pembagian ini bertujuan untuk menguji performa model pada data yang belum pernah dilihat. Parameter random_state=42 memastikan hasil pembagian selalu konsisten.
"""

x = df[['user', 'place']].values
y = df['rating_normalized'].values

x_train, x_val, y_train, y_val = train_test_split(x, y, test_size=0.2, random_state=42)

"""### 5. Arsitektur Model Recommender (Collaborative Filtering)
Model RecommenderNet adalah model Collaborative Filtering berbasis neural network yang digunakan untuk memprediksi skor rating antara pengguna dan tempat wisata. Model ini mempelajari representasi vektor (embedding) dari pengguna dan tempat, serta bias masing-masing.

1. Parameter-Parameter Kunci:

- embedding_size: Ukuran dimensi dari vektor embedding. Dalam implementasi ini, nilainya adalah 50, artinya setiap pengguna dan tempat direpresentasikan dalam ruang vektor berdimensi 50.
- embeddings_initializer='he_normal': Inisialisasi bobot pada layer embedding menggunakan distribusi He normal, yang cocok untuk model non-linear dengan ReLU.
- embeddings_regularizer=keras.regularizers.l2(1e-6): Regularisasi L2 digunakan untuk mencegah overfitting dengan menghukum bobot embedding besar.

2. Komponen Arsitektur Model:

- self.user_embedding: Layer embedding yang mengubah ID pengguna menjadi vektor berdimensi 50.
- self.place_embedding: Layer embedding yang mengubah ID tempat menjadi vektor berdimensi 50.
- self.user_bias: Layer embedding satu dimensi yang memberikan bias khusus untuk setiap pengguna.
- self.place_bias: Layer embedding satu dimensi yang memberikan bias khusus untuk setiap tempat.

3. Fungsi call(inputs):

- Input model adalah tensor 2D dengan 2 kolom: inputs[:, 0] untuk ID pengguna, dan inputs[:, 1] untuk ID tempat.
- Langkah-langkah:
  - Ambil vektor embedding dan bias dari pengguna dan tempat.
  - Lakukan operasi dot product antara vektor pengguna dan tempat untuk menghitung skor kecocokan.
  -Tambahkan bias pengguna dan bias tempat ke skor tersebut.


"""

class RecommenderNet(tf.keras.Model):
    def __init__(self, num_users, num_places, embedding_size, **kwargs):
        super(RecommenderNet, self).__init__(**kwargs)
        self.user_embedding = layers.Embedding(
            num_users, embedding_size,
            embeddings_initializer='he_normal',
            embeddings_regularizer=keras.regularizers.l2(1e-6)
        )
        self.user_bias = layers.Embedding(num_users, 1)

        self.place_embedding = layers.Embedding(
            num_places, embedding_size,
            embeddings_initializer='he_normal',
            embeddings_regularizer=keras.regularizers.l2(1e-6)
        )
        self.place_bias = layers.Embedding(num_places, 1)

    def call(self, inputs):
        user_vector = self.user_embedding(inputs[:, 0])
        user_bias = self.user_bias(inputs[:, 0])
        place_vector = self.place_embedding(inputs[:, 1])
        place_bias = self.place_bias(inputs[:, 1])
        dot_user_place = tf.reduce_sum(user_vector * place_vector, axis=1, keepdims=True)
        return dot_user_place + user_bias + place_bias

"""### 6. Definisi Model Rekomendasi – RecommenderNet
Model RecommenderNet adalah implementasi dari pendekatan Collaborative Filtering berbasis neural network. Model ini mempelajari representasi laten (latent factors) dari pengguna dan tempat wisata dalam bentuk vektor embedding.

Komponen Utama Model:

- user_embedding dan place_embedding

Lapisan ini memetakan ID pengguna dan ID tempat wisata ke dalam vektor embedding berdimensi tetap. Vektor ini merepresentasikan karakteristik laten dari masing-masing entitas.

- user_bias dan place_bias

Menambahkan bias masing-masing pengguna dan tempat wisata ke dalam prediksi, yang membantu menangkap kecenderungan umum dari pengguna (misalnya sering memberi rating tinggi) atau tempat (misalnya populer secara umum).

- dot_user_place

Mengukur tingkat kecocokan antara pengguna dan tempat wisata dengan menghitung dot product dari vektor embedding keduanya.

- Output akhir

Prediksi skor interaksi dihitung dengan menjumlahkan dot_user_place, user_bias, dan place_bias. Skor ini menggambarkan seberapa cocok suatu tempat bagi pengguna tertentu.
"""

class RecommenderNet(tf.keras.Model):
    def __init__(self, num_users, num_places, embedding_size, **kwargs):
        super(RecommenderNet, self).__init__(**kwargs)
        self.user_embedding = layers.Embedding(
            num_users, embedding_size,
            embeddings_initializer='he_normal',
            embeddings_regularizer=keras.regularizers.l2(1e-6)
        )
        self.user_bias = layers.Embedding(num_users, 1)

        self.place_embedding = layers.Embedding(
            num_places, embedding_size,
            embeddings_initializer='he_normal',
            embeddings_regularizer=keras.regularizers.l2(1e-6)
        )
        self.place_bias = layers.Embedding(num_places, 1)

    def call(self, inputs):
        user_vector = self.user_embedding(inputs[:, 0])
        user_bias = self.user_bias(inputs[:, 0])
        place_vector = self.place_embedding(inputs[:, 1])
        place_bias = self.place_bias(inputs[:, 1])
        dot_user_place = tf.reduce_sum(user_vector * place_vector, axis=1, keepdims=True)
        return dot_user_place + user_bias + place_bias

"""### 7. Kompilasi Model Rekomendasi
Setelah mendefinisikan arsitektur model RecommenderNet, langkah selanjutnya adalah melakukan kompilasi dengan konfigurasi sebagai berikut:

- Loss function
Model menggunakan Mean Squared Error (MSE) sebagai fungsi loss. Fungsi ini mengukur selisih kuadrat antara nilai prediksi dan rating sebenarnya, dan umum digunakan untuk regresi.

- Optimizer
Optimizer yang digunakan adalah Adam, yaitu metode optimasi berbasis momentum yang bekerja efisien untuk data berskala besar dan parameter tinggi. Learning rate ditetapkan sebesar 0.001.

- Evaluation metrics
Dua metrik tambahan digunakan untuk mengevaluasi performa model selama pelatihan dan pengujian:
  - MeanAbsoluteError (MAE) – mengukur rata-rata selisih absolut antara prediksi dan label asli.
  - RootMeanSquaredError (RMSE) – mengukur akar dari rata-rata selisih kuadrat, sensitif terhadap kesalahan besar.
"""

model = RecommenderNet(num_users, num_places, embedding_size=50)
model.compile(
    loss='mean_squared_error',
    optimizer=keras.optimizers.Adam(learning_rate=0.001),
    metrics=[
        tf.keras.metrics.MeanAbsoluteError(),
        tf.keras.metrics.RootMeanSquaredError()
    ]
)

"""### 8. Pelatihan Model (Model Training)
Model dilatih menggunakan data pelatihan dan validasi dengan parameter berikut:
- Batch Size: 64 – jumlah sampel yang diproses sebelum model diperbarui.
- Epochs: 100 – jumlah maksimum iterasi pelatihan.
- Validation Data: digunakan untuk mengevaluasi performa model pada data yang tidak dilatih.
- Early Stopping: menghentikan pelatihan lebih awal jika val_loss tidak membaik selama 7 epoch berturut-turut, serta mengembalikan bobot model terbaik (dengan restore_best_weights=True).

Callback EarlyStopping membantu mencegah overfitting dan mempercepat pelatihan dengan menghentikan proses saat model tidak lagi mengalami peningkatan.
"""

early_stopping = EarlyStopping(monitor='val_loss', patience=7, restore_best_weights=True)

history = model.fit(
    x=x_train.astype('int32'),
    y=y_train,
    batch_size=64,
    epochs=100,
    validation_data=(x_val.astype('int32'), y_val),
    callbacks=[early_stopping],
    verbose=1
)

"""### 9. Menentukan Tempat yang Belum Dikunjungi oleh Pengguna
- user_ID: Mengambil satu user secara acak dari data.
- places_visited: Menyimpan daftar place yang sudah dikunjungi oleh user tersebut.
- places_not_visited: Menyimpan daftar tempat yang belum pernah dikunjungi oleh user, dengan membandingkan semua tempat (all_places) terhadap tempat yang telah dikunjungi (places_visited).

Langkah ini penting untuk membuat rekomendasi hanya pada tempat-tempat baru bagi pengguna.
"""

# Ambil user secara acak
user_ID = df['user'].sample(1).iloc[0]
places_visited = df[df['user'] == user_ID]['place'].tolist()
all_places = df['place'].unique()
places_not_visited = [place for place in all_places if place not in places_visited]

"""### 10. Rekomendasi Tempat Wisata Berdasarkan Collaborative Filtering
1. Cek apakah semua tempat sudah dikunjungi
- Jika places_not_visited kosong, berarti pengguna telah mengunjungi semua tempat wisata.
2. Prediksi rating tempat yang belum dikunjungi
- Membentuk array kombinasi user–place (user_place_array).
- Model memprediksi rating untuk masing-masing tempat.
3. Skala ulang prediksi ke rentang rating asli
- Mengembalikan hasil prediksi ke skala awal (misal 1–5).
4. Ambil 10 tempat teratas
- Urutkan berdasarkan skor prediksi tertinggi.
5. Dekode ID user dan tempat ke bentuk aslinya
- Gunakan LabelEncoder.inverse_transform() untuk menampilkan hasil akhir dalam format yang dimengerti.
6. Tampilkan hasil rekomendasi
- Menampilkan nama tempat dan rating prediksi untuk user yang dipilih secara acak.
"""

if len(places_not_visited) == 0:
    print("Pengguna ini sudah mengunjungi semua tempat.")
else:
    user_place_array = np.array([[user_ID, place] for place in places_not_visited]).astype('int32')
    predictions = model.predict(user_place_array).flatten()

    # Skala ulang ke rating asli
    predictions_rescaled = predictions * (max_rating - min_rating) + min_rating

    # Ambil top 10
    top_n = min(10, len(places_not_visited))
    top_indices = predictions_rescaled.argsort()[-top_n:][::-1]
    recommended_place_ids = [places_not_visited[i] for i in top_indices]
    predicted_scores = [predictions_rescaled[i] for i in top_indices]

    # Decode ke ID asli
    recommended_place_ids_original = place_encoder.inverse_transform(recommended_place_ids)
    user_id_original = user_encoder.inverse_transform([user_ID])[0]

    # Output
    print(f"\nRekomendasi tempat wisata untuk pengguna: {user_id_original}")
    print("="*50)
    for place_id, score in zip(recommended_place_ids_original, predicted_scores):
        place_info = df_tourism[df_tourism['Place_Id'] == place_id]
        if not place_info.empty:
            place_name = place_info['Place_Name'].values[0]
            print(f"- {place_name} (Rating Prediksi: {score:.2f})")
        else:
            print(f"- Tempat dengan ID {place_id} (Rating Prediksi: {score:.2f})")

"""#  Evaluasi Sistem Rekomendasi
Evaluasi sistem rekomendasi bertujuan untuk mengukur seberapa baik model dalam menyarankan tempat wisata yang relevan dan sesuai preferensi pengguna. Dalam proyek ini, dilakukan dua pendekatan utama dalam pembuatan sistem rekomendasi, yaitu:

1. Content-Based Filtering (CBF)

2. Collaborative Filtering (CF) berbasis neural network menggunakan TensorFlow

Masing-masing pendekatan dievaluasi dengan metrik yang sesuai untuk menilai akurasi dan relevansi rekomendasi yang dihasilkan.

## 1) Evaluasi Content-Based Filtering (CBF)
Metode Evaluasi: Precision@K (dengan K = 10)
Content-Based Filtering menggunakan fitur konten (seperti nama tempat dan kategori) untuk menghitung kemiripan antar tempat wisata, lalu merekomendasikan tempat-tempat yang paling mirip.

Untuk mengevaluasi performa CBF, digunakan metrik Precision@10, yaitu rasio jumlah tempat yang relevan (dengan kategori sama seperti tempat asal) terhadap jumlah total rekomendasi (10 tempat).

### 1. Menentukan Tempat Uji Coba untuk Evaluasi Content-Based Filtering

Dalam proses evaluasi sistem rekomendasi berbasis konten (Content-Based Filtering), langkah awal yang dilakukan adalah memilih sebuah tempat wisata sebagai titik acuan atau tempat uji coba. Pada tahap ini, tempat yang dipilih adalah Museum Taman Prasasti. Pemilihan tempat ini bukan tanpa alasan—Museum Taman Prasasti memiliki karakteristik kategori yang cukup spesifik, yaitu budaya, sehingga cocok untuk menguji kemampuan model dalam menemukan tempat wisata lain yang memiliki kesamaan konten.

Melalui potongan kode tersebut, sistem mencari data lengkap dari tempat yang dimaksud di dalam DataFrame df_tourism, lalu mengambil nilai kategorinya. Kategori inilah yang nantinya akan dijadikan sebagai dasar dalam mengevaluasi hasil rekomendasi. Jika sebagian besar tempat yang direkomendasikan oleh model juga termasuk dalam kategori budaya, maka bisa dikatakan bahwa model mampu mengenali dan mempertahankan kesesuaian konteks dalam rekomendasi yang dihasilkannya.

Langkah ini menjadi fondasi penting sebelum menghitung metrik seperti Precision@10 karena kita perlu tahu terlebih dahulu apa kategori "benar" dari tempat yang sedang diuji, sehingga kita bisa menentukan apakah rekomendasi yang dihasilkan tergolong relevan atau tidak.
"""

# Tentukan tempat ujicoba
place_name = 'Museum Taman Prasasti'
find_place   = df_tourism[df_tourism['Place_Name'] == place_name]
base_category = find_place['Category'].iloc[0]
print(f"{place_name} → kategori = {base_category}")

"""### 2. Menyusun Ulang Fungsi Rekomendasi untuk Evaluasi

Pada tahap evaluasi sistem rekomendasi berbasis konten, fungsi rekomendasi disusun ulang agar lebih fleksibel dan siap digunakan dalam berbagai skenario uji. Fungsi ini dinamai get_recommendations, dan dilengkapi dengan parameter tambahan top_n untuk menentukan jumlah hasil rekomendasi yang diinginkan—default-nya adalah 10.

Secara umum, fungsi ini bekerja dengan terlebih dahulu memeriksa apakah nama tempat yang diberikan (place_name) terdapat dalam indeks data. Jika tidak ditemukan, fungsi akan mengembalikan DataFrame kosong sebagai tanda bahwa tempat tersebut tidak valid.

Jika tempat valid ditemukan, langkah berikutnya adalah menghitung skor kemiripan (cosine similarity) antara tempat tersebut dengan semua tempat lainnya yang ada di dalam data. Skor-skor ini kemudian diurutkan dari yang paling mirip ke yang paling tidak mirip, lalu diambil sejumlah top_n tempat teratas (dengan pengecualian tempat asal itu sendiri, karena tidak masuk akal merekomendasikan dirinya sendiri).

Fungsi kemudian mengembalikan informasi dasar dari tempat-tempat hasil rekomendasi, yaitu Place_Id, Place_Name, dan Category. Struktur ini memudahkan kita untuk mengevaluasi seberapa relevan rekomendasi yang dihasilkan berdasarkan kesamaan kategori dengan tempat asal. Penyusunan ulang fungsi ini penting agar dapat mendukung pengujian yang konsisten dan terukur selama proses evaluasi.
"""

# 🔢 Buat ulang fungsi rekomendasi dengan argumen top_n
def get_recommendations(place_name, top_n=10, cosine_sim=cosine_sim):
    if place_name not in indices:
        return pd.DataFrame()  # atau raise error/custom message

    idx = indices[place_name]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    # ambil sesuai top_n
    sim_scores = sim_scores[1 : top_n+1]
    place_indices = [i[0] for i in sim_scores]

    return df_tourism.iloc[place_indices][['Place_Id','Place_Name','Category']]

"""### 3.Menjalankan Rekomendasi CBF untuk Evaluasi

Setelah fungsi rekomendasi disusun ulang, langkah selanjutnya adalah menjalankan fungsi tersebut untuk menghasilkan daftar tempat wisata yang direkomendasikan. Dalam konteks ini, digunakan place_name tertentu—yaitu Museum Taman Prasasti—sebagai titik awal rekomendasi. Parameter top_n diset ke 10, sehingga model akan mengembalikan 10 tempat yang paling mirip berdasarkan perhitungan kemiripan konten.

Hasil dari fungsi ini adalah DataFrame yang berisi 10 tempat wisata teratas yang memiliki nilai kemiripan tertinggi terhadap tempat asal. Informasi yang ditampilkan hanya kolom Place_Name dan Category, karena kedua atribut tersebut yang paling relevan untuk mengevaluasi kesesuaian rekomendasi dengan kategori tempat awal.

Langkah ini menjadi inti dari proses evaluasi karena dari hasil inilah kita bisa menilai seberapa baik model Content-Based Filtering mampu mengenali dan merekomendasikan tempat yang relevan dari sisi konten deskriptif, khususnya kategori wisata.
"""

# Jalankan rekomendasi CBF (top-10)
recommendations = get_recommendations(place_name, top_n=10)
print(recommendations[['Place_Name','Category']])

"""### 4. Mengukur Kualitas Rekomendasi dengan Precision@10

Setelah mendapatkan daftar 10 tempat wisata hasil rekomendasi dari model Content-Based Filtering, langkah berikutnya adalah menghitung metrik evaluasi untuk mengukur relevansi hasil tersebut. Dalam hal ini, metrik yang digunakan adalah Precision@10, yaitu rasio jumlah tempat yang memiliki kategori sama dengan tempat asal terhadap total jumlah rekomendasi yang diberikan.

Proses ini dilakukan dengan cara membandingkan kategori dari setiap rekomendasi dengan kategori dasar (base_category) dari tempat asal. Jika suatu tempat memiliki kategori yang sama atau memuat kata kunci yang identik, maka ia dianggap sebagai relevan. Seluruh jumlah tempat yang relevan kemudian dibagi dengan jumlah total rekomendasi (dalam hal ini 10) untuk mendapatkan nilai precision.

Nilai Precision@10 yang tinggi menunjukkan bahwa model berhasil merekomendasikan tempat-tempat yang sejenis dan sesuai dengan preferensi pengguna berdasarkan kategori, yang dalam konteks pariwisata bisa sangat penting untuk menjaga kesesuaian minat wisatawan.
"""

# Hitung berapa rekomendasi yang punya kategori sama dengan base_category
relevant = recommendations['Category'].apply(lambda cat: base_category in cat).sum()
precision = relevant / len(recommendations)
print(f"Precision: {relevant}/{len(recommendations)} = {precision:.2%}")

"""### Interpretasi Evaluasi Content-Based Filtering (CBF)
Pada tahap evaluasi ini, sistem rekomendasi diuji menggunakan satu tempat wisata sebagai acuan, yaitu Museum Taman Prasasti. Tempat ini memiliki kategori utama Budaya. Model CBF kemudian diminta untuk menghasilkan 10 rekomendasi tempat wisata lain yang dianggap paling mirip berdasarkan kemiripan teks antara nama tempat dan kategorinya (menggunakan teknik TF-IDF dan cosine similarity).

Setelah hasil rekomendasi diperoleh, kategori dari setiap tempat rekomendasi dibandingkan dengan kategori asal. Hasilnya, seluruh tempat yang direkomendasikan berada dalam kategori yang sama atau sangat berkaitan, yakni Budaya. Hal ini menghasilkan Precision@10 sebesar 100%, yang berarti semua rekomendasi relevan terhadap konteks kategori tempat asal.

Hasil evaluasi ini menunjukkan bahwa pendekatan Content-Based Filtering bekerja sangat baik untuk tempat wisata yang memiliki deskripsi kategori yang kuat dan konsisten. Dalam kasus ini, penggunaan fitur teks sederhana seperti nama tempat dan kategori sudah cukup untuk menangkap hubungan semantik antar tempat.

Namun, penting untuk dicatat bahwa evaluasi hanya dilakukan pada satu contoh uji coba. Untuk mendapatkan gambaran kinerja yang lebih menyeluruh, perlu dilakukan pengujian terhadap lebih banyak tempat dari berbagai kategori, seperti Alam, Hiburan, atau Kuliner, agar dapat melihat konsistensi model dalam berbagai konteks.

Secara keseluruhan, model CBF menunjukkan performa yang akurat dan relevan untuk memberikan rekomendasi berdasarkan kemiripan konten, terutama ketika informasi kategori cukup informatif dan representatif.

## 2) Evaluasi Collaborative Filtering (CF) Berbasis Neural Network
Pendekatan Collaborative Filtering (CF) berbasis neural network digunakan untuk memprediksi rating atau preferensi pengguna terhadap tempat wisata, berdasarkan pola interaksi pengguna sebelumnya. Berbeda dengan Content-Based Filtering yang menggunakan informasi konten tempat wisata, pendekatan ini murni mengandalkan interaksi historis antar pengguna dan item.

Dalam proyek ini, CF diimplementasikan menggunakan TensorFlow, dan model dilatih untuk mempelajari representasi laten (latent factors) dari pengguna dan tempat wisata dalam bentuk vektor embedding. Proses pelatihan dilakukan menggunakan data rating yang dibagi menjadi data pelatihan dan validasi.

Metode Evaluasi: MAE dan RMSE
Untuk mengevaluasi performa model CF, digunakan dua metrik regresi yang umum digunakan dalam sistem rekomendasi:
1. MAE (Mean Absolute Error): Mengukur rata-rata selisih absolut antara rating yang diprediksi dan rating aktual.
2. RMSE (Root Mean Squared Error): Mengukur akar dari rata-rata kuadrat selisih antara rating yang diprediksi dan aktual, memberikan penalti lebih besar untuk kesalahan yang besar.

Kedua metrik ini dihitung selama proses pelatihan dan divisualisasikan menggunakan grafik, baik untuk data pelatihan maupun data validasi.

### Hasil Evaluasi Model Collaborative Filtering
Evaluasi model dilakukan menggunakan metrik Mean Absolute Error (MAE) dan Root Mean Squared Error (RMSE) pada data validasi. Nilai akhir diperoleh dari epoch terakhir selama proses training model.
"""

final_mae = history.history['val_mean_absolute_error'][-1]
final_rmse = history.history['val_root_mean_squared_error'][-1]
print(f"Final Validation MAE: {final_mae:.4f}")
print(f"Final Validation RMSE: {final_rmse:.4f}")

"""### Hasil Evaluasi Model Collaborative Filtering (CF)
Model Collaborative Filtering Anda menunjukkan hasil evaluasi sebagai berikut:

- Final Validation MAE (Mean Absolute Error): **0.3575**  
- Final Validation RMSE (Root Mean Squared Error): **0.4288**

Angka-angka ini mencerminkan performa model dalam memprediksi rating pada data validasi.  
MAE sebesar 0.3575 berarti rata-rata selisih absolut antara rating prediksi dan rating aktual adalah sekitar **0.36**.  
Sedangkan RMSE sebesar 0.4288 mengindikasikan deviasi rata-rata kuadrat (yang lebih sensitif terhadap error besar) adalah sekitar **0.43**.

Kedua nilai metrik ini tergolong **rendah**, menunjukkan bahwa model memiliki kemampuan prediksi yang cukup baik dan rating yang diprediksi relatif dekat dengan nilai sebenarnya (mengingat skala rating umum, misalnya 1–5).

### 1. Visualisasi Mean Absolute Error (MAE) Selama Pelatihan
Kode ini digunakan untuk memvisualisasikan perkembangan nilai Mean Absolute Error (MAE) dari model Collaborative Filtering berbasis neural network selama proses pelatihan. Grafik yang dihasilkan menampilkan dua kurva: satu untuk data pelatihan (Train) dan satu untuk data validasi (Validation), yang menunjukkan bagaimana performa model dalam memprediksi rating pada kedua dataset tersebut seiring bertambahnya epoch. Visualisasi ini penting untuk memantau apakah model belajar dengan baik atau mulai mengalami overfitting ketika performa validasi mulai menurun.
"""

# Plot MAE selama pelatihan
plt.plot(history.history['mean_absolute_error'])
plt.plot(history.history['val_mean_absolute_error'])
plt.title('Model Metrics – MAE')
plt.ylabel('Mean Absolute Error')
plt.xlabel('Epoch')
plt.legend(['Train','Validation'])
plt.show()

"""### Grafik: Model Metrics – MAE (Mean Absolute Error)

Grafik ini menampilkan perkembangan nilai Mean Absolute Error (MAE) selama proses pelatihan model Collaborative Filtering berbasis Neural Network Anda. Terdapat dua garis pada grafik:

- Garis biru menunjukkan nilai MAE pada data pelatihan (Train).
- Garis oranye menunjukkan nilai MAE pada data validasi (Validation).

Interpretasi:
1. Performa pada Data Pelatihan (Garis Biru):
- MAE pada data pelatihan menunjukkan penurunan yang konsisten dan signifikan dari epoch awal hingga akhir. Ini mengindikasikan bahwa model Anda berhasil belajar dengan sangat baik dari data pelatihan dan mampu mengurangi kesalahan prediksi secara progresif seiring bertambahnya iterasi pelatihan. Model berhasil menyesuaikan diri dengan pola-pola dalam data yang telah dilihatnya.

2. Performa pada Data Validasi (Garis Oranye):
- MAE pada data validasi juga menunjukkan penurunan yang baik di awal pelatihan (sekitar epoch 0 hingga 5). Ini menandakan bahwa model mampu menggeneralisasi dengan baik pada data baru yang belum pernah dilihat sebelumnya pada fase awal pelatihan.
- Namun, setelah sekitar epoch ke-8 hingga ke-10, penurunan MAE pada data validasi mulai melambat dan cenderung stagnan, bahkan sedikit meningkat di epoch-epoch terakhir (sekitar epoch 15-20).
- Fenomena ini adalah indikasi adanya overfitting ringan. Model mulai terlalu "menghafal" pola-pola spesifik pada data pelatihan (sehingga MAE train terus turun drastis), namun kehilangan kemampuannya untuk menggeneralisasi dengan baik pada data yang tidak dikenal (data validasi). Kesenjangan antara MAE train dan MAE validation menjadi semakin lebar di epoch-epoch akhir.

### Visualisasi Root Mean Squared Error (RMSE) Selama Pelatihan
Kode ini digunakan untuk memplot perkembangan nilai Root Mean Squared Error (RMSE) dari model Collaborative Filtering selama proses pelatihan. Grafik memperlihatkan perbandingan error antara data pelatihan dan validasi pada setiap epoch. RMSE memberikan gambaran seberapa besar deviasi antara prediksi dan nilai aktual, dengan penalti lebih besar untuk kesalahan yang lebih jauh. Visualisasi ini membantu mengidentifikasi apakah model terus membaik, stagnan, atau mulai mengalami overfitting seiring berjalannya pelatihan.
"""

# Plot RMSE selama pelatihan
plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('Model Metrics – RMSE')
plt.ylabel('Root Mean Squared Error')
plt.xlabel('Epoch')
plt.legend(['Train','Validation'])
plt.show()

"""### Grafik: Model Metrics – RMSE (Root Mean Squared Error)

Grafik ini menggambarkan perubahan nilai Root Mean Squared Error (RMSE) selama proses pelatihan model Collaborative Filtering menggunakan Neural Network Anda. Sama seperti grafik MAE, terdapat dua garis yang ditampilkan:

- Garis biru menunjukkan RMSE pada data pelatihan (Train).
- Garis oranye menunjukkan RMSE pada data validasi (Validation).
Interpretasi:

1. Performa pada Data Pelatihan (Garis Biru):
- RMSE pada data pelatihan menunjukkan penurunan yang konsisten dan signifikan seiring bertambahnya jumlah epoch. Ini menandakan bahwa model belajar dengan sangat baik dari data pelatihan dan mampu meminimalkan kesalahan prediksi secara efektif pada data yang telah dilihatnya. Penurunan yang curam ini menunjukkan bahwa model terus menyesuaikan bobotnya untuk lebih akurat memprediksi rating yang ada dalam dataset pelatihan.

2. Performa pada Data Validasi (Garis Oranye):
- RMSE pada data validasi juga menunjukkan penurunan awal yang sehat (sekitar epoch 0 hingga 5). Ini menunjukkan bahwa model mampu menggeneralisasi dengan baik pada data baru di fase awal pelatihan.
- Namun, setelah kira-kira epoch ke-8 hingga ke-10, penurunan RMSE pada data validasi mulai melambat secara drastis, stagnan, dan bahkan sedikit meningkat di epoch-epoch terakhir (sekitar epoch 15-20).
- Pola ini sangat mirip dengan grafik MAE validasi dan merupakan indikasi yang kuat adanya overfitting ringan. Model menjadi terlalu spesifik terhadap data pelatihan, sehingga kinerja pada data yang belum pernah dilihat (data validasi) mulai terganggu. Kesenjangan antara RMSE train dan RMSE validation terus melebar.

# Kesimpulan Evaluasi Sistem Rekomendasi

Evaluasi terhadap dua pendekatan sistem rekomendasi, yaitu **Content-Based Filtering (CBF)** dan **Collaborative Filtering (CF)** berbasis neural network, menunjukkan hasil yang cukup menjanjikan dalam konteks rekomendasi tempat wisata di Jakarta. Berikut adalah rangkuman kesimpulan dari masing-masing pendekatan:

### 1. Content-Based Filtering (CBF)
- Dilakukan evaluasi menggunakan **Precision@10** terhadap tempat wisata _Museum Taman Prasasti_ yang memiliki kategori "Budaya".
- Hasil menunjukkan bahwa **10 dari 10 tempat** yang direkomendasikan memiliki kategori yang sama atau sangat relevan.
- **Precision@10 mencapai 100%**, yang menandakan bahwa model berhasil merekomendasikan tempat-tempat wisata yang sangat sesuai dari segi konten deskriptif.
- Pendekatan CBF terbukti sangat efektif, terutama ketika informasi kategori cukup kuat dan representatif.
- Namun, evaluasi hanya dilakukan pada satu tempat. Untuk generalisasi yang lebih baik, evaluasi sebaiknya diperluas ke lebih banyak tempat dan kategori yang beragam.

### 2. Collaborative Filtering (CF) Berbasis Neural Network
- Evaluasi dilakukan dengan memantau metrik **MAE (Mean Absolute Error)** dan **RMSE (Root Mean Squared Error)** selama proses pelatihan.
- Baik MAE maupun RMSE pada data pelatihan menunjukkan penurunan yang konsisten, menandakan bahwa model berhasil mempelajari pola interaksi pengguna dengan baik.
- Pada data validasi, metrik juga menurun di awal pelatihan namun cenderung **stagnan atau sedikit meningkat setelah epoch ke-15**, menandakan potensi **overfitting ringan**.
- Meskipun demikian, nilai error tetap rendah (MAE 0.3575 dan RMSE 0.4288), menunjukkan bahwa model memiliki kemampuan prediksi yang cukup akurat.
- Ke depan, performa model dapat lebih ditingkatkan dengan menggunakan **early stopping**, **dropout**, atau strategi regularisasi lainnya untuk menghindari overfitting.

###  Rangkuman Umum:
- **CBF sangat akurat** dalam menangkap kesamaan konten, cocok untuk sistem yang memiliki metadata atau deskripsi yang kaya.
- **CF berbasis neural network** memberikan prediksi yang baik, terutama untuk sistem dengan interaksi pengguna-tempat yang cukup banyak.
- Kombinasi keduanya atau pendekatan hybrid bisa menjadi solusi untuk meningkatkan kualitas rekomendasi lebih lanjut.

Langkah selanjutnya dapat mencakup:
- Evaluasi lebih luas terhadap tempat dari kategori berbeda.
- Penerapan teknik hybrid untuk memadukan kekuatan CBF dan CF.
- Integrasi feedback pengguna secara langsung untuk terus menyempurnakan model rekomendasi.
"""